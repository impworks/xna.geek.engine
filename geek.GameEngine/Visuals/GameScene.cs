using Microsoft.Xna.Framework;
using geek.GameEngine.Scrolling;

namespace geek.GameEngine.Visuals
{
	/// <summary>
	/// The base class that serves as a root for all visual objects on the scene,
	/// allowing scrolling and more.
	/// </summary>
	public class GameScene : ObjectGroup
	{
		#region Constructors

		public GameScene()
		{
			_ScrollManager = NoScroll.Instance;
			Dimensions = GameCore.ScreenSize;
			LevelRect = new Rectangle(0, 0, (int)Dimensions.X, (int)Dimensions.Y);
			Background = Color.White;
		}

		public GameScene(Vector2 size)
		{
			_ScrollManager = NoScroll.Instance;
			Dimensions = size;
			LevelRect = new Rectangle(0, 0, (int)size.X, (int)size.Y);
			Background = Color.White;
		}

		public GameScene(int x, int y)
		{
			_ScrollManager = NoScroll.Instance;
			Dimensions = new Vector2(x, y);
			LevelRect = new Rectangle(0, 0, x, y);
			Background = Color.White;
		}

		#endregion

		#region Fields

		/// <summary>
		/// Gets or sets the size of the level to scroll within.
		/// </summary>
		public Vector2 Dimensions { get; private set; }

		/// <summary>
		/// Gets or sets the rectangle of the level.
		/// </summary>
		public Rectangle LevelRect { get; private set; }

		/// <summary>
		/// Gets or sets the flag indicating that scrolling may be unrestricted to frame dimensions.
		/// </summary>
		public bool AllowScrollOutside;

		/// <summary>
		/// Gets or sets the background color for current level.
		/// </summary>
		public Color Background;

		/// <summary>
		/// The scrolling mode currently active.
		/// </summary>
		private IScrollManager _ScrollManager;

		/// <summary>
		/// The current scroll offset generated by scroll manager.
		/// </summary>
		private Vector2 _ScrollOffset;

		/// <summary>
		/// The current scroll offset used in calculations.
		/// </summary>
		private Vector2 _NegatedScrollOffset;

		#endregion

		#region Methods

		public override Vector2 RelativePosition
		{
			get { return _NegatedScrollOffset; }
		}

		public override void Update()
		{
			if (!(_ScrollManager is NoScroll))
			{
				_ScrollOffset = _ScrollManager.UpdateScrolling(_ScrollOffset);
				if (!AllowScrollOutside)
					ClampScrolling();

				_NegatedScrollOffset = -_ScrollOffset;
			}

			base.Update();
		}

		/// <summary>
		/// Limit scroll offset within frame dimensions.
		/// </summary>
		/// <returns></returns>
		private void ClampScrolling()
		{
			if (_ScrollOffset.X < 0)
				_ScrollOffset.X = 0;
			else if (_ScrollOffset.X > Dimensions.X)
				_ScrollOffset.X = Dimensions.X;

			if (_ScrollOffset.Y < 0)
				_ScrollOffset.Y = 0;
			else if (_ScrollOffset.Y > Dimensions.Y)
				_ScrollOffset.Y = Dimensions.Y;
		}

		/// <summary>
		/// The handler to be called on level start.
		/// </summary>
		public virtual void OnLevelStarted()
		{}

		/// <summary>
		/// The handler to be called on level end.
		/// </summary>
		public virtual void OnLevelEnded()
		{}

		#endregion
	}
}
